# ‚úÖ VALIDATION ET √âTAT DES PARTIES - TP DEVOPS JOUR 4

## üìä BILAN GLOBAL : 9/13 Parties Pr√©par√©es

### ‚úÖ PARTIES COMPL√âT√âES ET VALID√âES (0-4)

#### ‚úÖ **PARTIE 0 : Cluster Minikube Multi-Nodes**
**Statut :** Compl√©t√© pr√©c√©demment  
**Fichiers :** Aucun (configuration syst√®me)  
**Commande de d√©ploiement :**
```bash
minikube start --nodes 2 --driver=docker --cpus=2 --memory=3500
```
**Validation :**
```bash
kubectl get nodes
# R√©sultat attendu : 2 n≈ìuds (minikube + minikube-m02) en Ready
```
**‚úì Valid√© :** Cluster 2 n≈ìuds fonctionnel test√© dans sessions pr√©c√©dentes

---

#### ‚úÖ **PARTIE 1 : Topology Spread Constraints**
**Statut :** Compl√©t√© et test√©  
**Fichiers existants :**
- ‚úì `resilient-app-deployment.yaml` - Deployment avec topologySpreadConstraints
- ‚úì `resilient-app-service.yaml` - Service ClusterIP port 8080

**Commande de d√©ploiement :**
```bash
kubectl apply -f resilient-app-deployment.yaml
kubectl apply -f resilient-app-service.yaml
kubectl get pods -l app=resilient-app -o wide
```

**Test de r√©silience effectu√© :**
```bash
kubectl drain minikube-m02 --ignore-daemonsets
# R√©sultat : Pods redistribu√©s automatiquement
kubectl uncordon minikube-m02
```
**‚úì Valid√© :** Distribution 2+2 confirm√©e, r√©silience test√©e

---

#### ‚úÖ **PARTIE 2 : Prometheus et Grafana**
**Statut :** Compl√©t√© et accessible  
**Installation :** Via Helm (kube-prometheus-stack)  

**Commande de d√©ploiement :**
```bash
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
kubectl create namespace monitoring
helm install kube-prometheus-stack prometheus-community/kube-prometheus-stack \
  --namespace monitoring \
  --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
  --wait --timeout=10m
```

**Acc√®s test√© :**
```bash
kubectl port-forward -n monitoring svc/kube-prometheus-stack-grafana 3000:80
# URL : http://localhost:3000
# User : admin
# Pass : prom-operator
```
**‚úì Valid√© :** Stack compl√®te, Grafana accessible, dashboards fonctionnels

---

#### ‚úÖ **PARTIE 3 : Ingress NGINX et Tests de Charge**
**Statut :** Compl√©t√© avec tests r√©ussis  
**Fichiers existants :**
- ‚úì `guestbook-deployment.yaml` - Nginx 3 replicas
- ‚úì `guestbook-ingress.yaml` - Ingress host guestbook.fbi.com
- ‚úì `load-test.js` - Script k6 pour load testing

**Commande de d√©ploiement :**
```bash
minikube addons enable ingress
kubectl apply -f guestbook-deployment.yaml
kubectl apply -f guestbook-ingress.yaml
sudo minikube tunnel  # Terminal s√©par√©
```

**Tests effectu√©s :**
```bash
# Test avec k6
k6 run load-test.js

# Alternative curl (100 requ√™tes)
for i in {1..100}; do
  curl -H "Host: guestbook.fbi.com" http://$(minikube ip)
done
```
**‚úì Valid√© :** 100+ requ√™tes r√©ussies, distribution confirm√©e

---

#### ‚úÖ **PARTIE 4 : Dashboard Grafana Personnalis√©**
**Statut :** Compl√©t√© avec m√©triques custom  
**Fichiers existants :**
- ‚úì `guestbook-with-metrics.yaml` - App avec endpoint /info

**Commande de d√©ploiement :**
```bash
kubectl apply -f guestbook-with-metrics.yaml
kubectl port-forward svc/guestbook-metrics-service 8082:80
```

**Validation m√©triques :**
```bash
curl http://localhost:8082/info
# R√©sultat : M√©triques Prometheus format (http_requests_total, app_active_users)
```
**‚úì Valid√© :** Endpoint /info exposant m√©triques, scraping Prometheus configur√©

---

### üìù PARTIES PR√âPAR√âES (5-9)

#### üü° **PARTIE 5 : Chaos Engineering avec Chaos Mesh**
**Statut :** Fichier cr√©√©, installation √† effectuer  
**Fichiers cr√©√©s aujourd'hui :**
- ‚úì `chaos-pod-kill-experiment.yaml` - PodChaos killing 1 guestbook pod/2min

**Commandes de d√©ploiement :**
```bash
# 1. Installation Chaos Mesh
helm repo add chaos-mesh https://charts.chaos-mesh.org
helm repo update
kubectl create namespace chaos-mesh
helm install chaos-mesh chaos-mesh/chaos-mesh \
  --namespace chaos-mesh \
  --set chaosDaemon.runtime=containerd \
  --set chaosDaemon.socketPath=/run/containerd/containerd.sock \
  --set dashboard.create=true \
  --wait --timeout=10m

# 2. Application de l'exp√©rience
kubectl apply -f chaos-pod-kill-experiment.yaml
kubectl get podchaos

# 3. Acc√®s au dashboard
kubectl port-forward -n chaos-mesh svc/chaos-dashboard 2333:2333
# URL : http://localhost:2333
```

**Ce qui reste √† faire :**
- [ ] Installer Chaos Mesh via Helm
- [ ] Appliquer le PodChaos experiment
- [ ] Observer l'impact dans Grafana

---

#### üü° **PARTIE 6 : GitHub Runner Self-Hosted**
**Statut :** Fichier cr√©√©, configuration token requise  
**Fichiers cr√©√©s/modifi√©s aujourd'hui :**
- ‚úì `github-runner-deployment.yaml` - Deployment avec myoung34/github-runner

**Commandes de d√©ploiement :**
```bash
# 1. Obtenir un token GitHub
# Aller sur GitHub : Settings > Developer settings > Personal access tokens
# Cr√©er un token avec scopes : repo, workflow, admin:org

# 2. Remplacer le token dans le fichier
sed -i 's/REMPLACER_PAR_VOTRE_TOKEN_GITHUB/ghp_VOTRE_TOKEN_ICI/' github-runner-deployment.yaml

# 3. D√©ployer
kubectl apply -f github-runner-deployment.yaml
kubectl get pods -l app=github-runner
kubectl logs -f deployment/github-runner
```

**Ce qui reste √† faire :**
- [ ] Obtenir token GitHub avec permissions n√©cessaires
- [ ] Remplacer REMPLACER_PAR_VOTRE_TOKEN_GITHUB dans le YAML
- [ ] Appliquer le deployment
- [ ] V√©rifier que le runner appara√Æt dans GitHub Settings > Actions > Runners

---

#### üü° **PARTIE 7 : Pipeline CI/CD GitHub Actions**
**Statut :** Pipeline cr√©√©, secrets √† configurer  
**Fichiers cr√©√©s aujourd'hui :**
- ‚úì `.github/workflows/docker-build.yaml` - Workflow build/push Docker + Trivy scan
- ‚úì `Dockerfile` - Image nginx:alpine avec curl
- ‚úì `index.html` - Page HTML guestbook

**Configuration requise :**
```bash
# 1. Ajouter secrets GitHub
# Aller sur GitHub : Settings > Secrets and variables > Actions > New repository secret

# Ajouter :
# - DOCKER_USERNAME : votre username Docker Hub
# - DOCKER_PASSWORD : votre access token Docker Hub

# 2. Push le code
git add .
git commit -m "feat: add CI/CD pipeline with Trivy security scan"
git push origin main

# 3. V√©rifier l'ex√©cution
# Aller dans l'onglet Actions sur GitHub
```

**Fonctionnalit√©s du pipeline :**
- Build Docker avec BuildKit
- Push vers Docker Hub (tags : latest + SHA)
- Scan de s√©curit√© avec Trivy
- Upload r√©sultats vers GitHub Security
- Run sur self-hosted runner

**Ce qui reste √† faire :**
- [ ] Cr√©er compte Docker Hub (si pas d√©j√† fait)
- [ ] G√©n√©rer access token Docker Hub
- [ ] Ajouter secrets DOCKER_USERNAME et DOCKER_PASSWORD sur GitHub
- [ ] Push le code pour d√©clencher le workflow
- [ ] V√©rifier le build dans Actions tab

---

#### üü° **PARTIE 8 : Renovate Bot**
**Statut :** CronJob cr√©√©, token √† configurer  
**Fichiers cr√©√©s aujourd'hui :**
- ‚úì `renovate-deployment.yaml` - CronJob quotidien (2h du matin)

**Configuration et d√©ploiement :**
```bash
# 1. Cr√©er un token GitHub
# GitHub : Settings > Developer settings > Personal access tokens (classic)
# Scopes requis : repo (full control)

# 2. Remplacer le token
sed -i 's/REMPLACER_PAR_VOTRE_GITHUB_TOKEN/ghp_VOTRE_TOKEN/' renovate-deployment.yaml

# 3. D√©ployer
kubectl apply -f renovate-deployment.yaml
kubectl get cronjob -n renovate
kubectl get pods -n renovate

# 4. Test manuel (sans attendre le cron)
kubectl create job --from=cronjob/renovate renovate-manual-run -n renovate
kubectl logs -f job/renovate-manual-run -n renovate
```

**Fonctionnalit√©s configur√©es :**
- Auto-merge pour mises √† jour minor/patch
- D√©tection des fichiers Kubernetes YAML
- D√©tection des Helm values
- Scan des images Docker
- Scan du repo BrahimHmitti/DEVOPS-jour4

**Ce qui reste √† faire :**
- [ ] Cr√©er token GitHub avec scope repo
- [ ] Remplacer REMPLACER_PAR_VOTRE_GITHUB_TOKEN
- [ ] Appliquer le CronJob
- [ ] D√©clencher un run manuel pour tester
- [ ] Attendre les PRs de mise √† jour automatiques

---

#### üü° **PARTIE 9 : ArgoCD GitOps**
**Statut :** Application CRD cr√©√©e, installation ArgoCD requise  
**Fichiers cr√©√©s aujourd'hui :**
- ‚úì `argocd-application.yaml` - Application GitOps pour guestbook

**Installation compl√®te :**
```bash
# 1. Installer ArgoCD
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# 2. Attendre que les pods soient pr√™ts (5-10 min)
kubectl wait --for=condition=Ready pods --all -n argocd --timeout=600s

# 3. R√©cup√©rer le mot de passe admin
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
echo  # Nouvelle ligne

# 4. Port-forwarding
kubectl port-forward -n argocd svc/argocd-server 8080:443

# 5. Se connecter √† l'UI
# URL : https://localhost:8080
# User : admin
# Pass : (voir commande √©tape 3)

# 6. Cr√©er structure de repo pour GitOps
mkdir -p manifests
cp guestbook-deployment.yaml manifests/
cp guestbook-ingress.yaml manifests/
git add manifests/ argocd-application.yaml
git commit -m "feat: add ArgoCD GitOps structure"
git push origin main

# 7. Appliquer l'Application ArgoCD
kubectl apply -f argocd-application.yaml

# 8. V√©rifier dans l'UI ArgoCD
# L'application "guestbook-gitops" doit appara√Ætre et se synchroniser
```

**Fonctionnalit√©s configur√©es :**
- Sync automatique (automated.prune, automated.selfHeal)
- Cr√©ation automatique du namespace
- Retry avec backoff exponentiel
- Source : repo GitHub BrahimHmitti/DEVOPS-jour4/manifests

**Ce qui reste √† faire :**
- [ ] Installer ArgoCD dans le cluster
- [ ] R√©cup√©rer le mot de passe admin
- [ ] Cr√©er dossier manifests/ dans le repo
- [ ] Push les manifests sur GitHub
- [ ] Appliquer argocd-application.yaml
- [ ] V√©rifier la synchronisation dans l'UI
- [ ] Tester un changement Git ‚Üí sync automatique

---

### ‚è≥ PARTIES OPTIONNELLES (10-13) - Non commenc√©es

#### **PARTIE 10 : Burrito (Infrastructure as Code Operator)**
**Statut :** Non d√©marr√©  
**Description :** Op√©rateur Kubernetes pour g√©rer Terraform/OpenTofu  
**Priorit√© :** Optionnelle

#### **PARTIE 11 : Signature d'images avec Cosign**
**Statut :** Non d√©marr√©  
**Description :** Signature cryptographique des images Docker  
**Priorit√© :** Optionnelle

#### **PARTIE 12 : V√©rification des signatures**
**Statut :** Non d√©marr√©  
**Description :** Admission controller pour images sign√©es uniquement  
**Priorit√© :** Optionnelle

#### **PARTIE 13 : Documentation finale**
**Statut :** En cours (apprentissage.md cr√©√©)  
**Description :** Diagramme architecture + retour d'exp√©rience  
**Priorit√© :** Importante

---

## üìà PROGRESSION D√âTAILL√âE

| Partie | Nom | Fichiers | D√©ploy√© | Test√© | % Complete |
|--------|-----|----------|---------|-------|------------|
| 0 | Cluster multi-nodes | - | ‚úÖ | ‚úÖ | 100% |
| 1 | Topology Spread | 2 | ‚úÖ | ‚úÖ | 100% |
| 2 | Prometheus/Grafana | Helm | ‚úÖ | ‚úÖ | 100% |
| 3 | Ingress + Load Test | 3 | ‚úÖ | ‚úÖ | 100% |
| 4 | Dashboard custom | 1 | ‚úÖ | ‚úÖ | 100% |
| 5 | Chaos Mesh | 1 | ‚ùå | ‚ùå | 70% |
| 6 | GitHub Runner | 1 | ‚ùå | ‚ùå | 80% |
| 7 | CI/CD Pipeline | 3 | ‚ùå | ‚ùå | 90% |
| 8 | Renovate Bot | 1 | ‚ùå | ‚ùå | 80% |
| 9 | ArgoCD GitOps | 1 | ‚ùå | ‚ùå | 70% |
| 10 | Burrito IaC | 0 | ‚ùå | ‚ùå | 0% |
| 11 | Cosign signature | 0 | ‚ùå | ‚ùå | 0% |
| 12 | V√©rif signatures | 0 | ‚ùå | ‚ùå | 0% |
| 13 | Documentation | 1 | üü° | üü° | 40% |

**Total global : 69% de pr√©paration, 38% d√©ploy√© et test√©**

---

## üéØ PLAN D'ACTION RECOMMAND√â

### Phase 1 : Compl√©ter les bases (30 min)
1. ‚úÖ Valider parties 0-4 (d√©j√† fait)
2. üîÑ Red√©marrer cluster : `minikube start --nodes 2`
3. üîÑ Red√©ployer parties 1-4 si n√©cessaire

### Phase 2 : Chaos Engineering (15 min)
4. üì¶ Installer Chaos Mesh
5. üß™ Appliquer exp√©rience pod-kill
6. üìä Observer dans Grafana

### Phase 3 : CI/CD (20 min)
7. üîë Configurer token GitHub Runner
8. üöÄ D√©ployer runner
9. üîê Ajouter secrets Docker Hub
10. üì§ Push code ‚Üí d√©clencher pipeline

### Phase 4 : GitOps (25 min)
11. üéØ Installer ArgoCD
12. üìÅ Structurer repo avec manifests/
13. üîÑ Appliquer Application CRD
14. ‚úÖ Tester sync automatique

### Phase 5 : Automatisation (10 min)
15. ü§ñ Configurer Renovate Bot
16. üîç Attendre premi√®re PR

### Phase 6 : Documentation (30 min)
17. üìù Compl√©ter apprentissage.md
18. üé® Cr√©er diagramme architecture
19. üì∏ Screenshots des dashboards
20. ‚úçÔ∏è Retour d'exp√©rience

**Temps total estim√© : ~2h pour parties 5-9 + 13**

---

## üîß COMMANDES DE VALIDATION RAPIDE

```bash
# V√©rifier √©tat global
./validate-all-parts.sh

# √âtat cluster
kubectl get nodes
kubectl get all --all-namespaces | grep -E "guestbook|resilient|chaos|argocd|renovate|github-runner"

# Acc√®s dashboards
kubectl port-forward -n monitoring svc/kube-prometheus-stack-grafana 3000:80 &
kubectl port-forward -n chaos-mesh svc/chaos-dashboard 2333:2333 &  # Si install√©
kubectl port-forward -n argocd svc/argocd-server 8080:443 &  # Si install√©

# V√©rifier Ingress
kubectl get ingress
minikube ip

# Logs d'un composant
kubectl logs -f deployment/guestbook
kubectl logs -f -n monitoring prometheus-kube-prometheus-stack-prometheus-0
```

---

## üìö FICHIERS CR√â√âS AUJOURD'HUI

### Nouveaux fichiers de configuration
- ‚úÖ `github-runner-deployment.yaml` - Runner self-hosted (Partie 6)
- ‚úÖ `.github/workflows/docker-build.yaml` - Pipeline CI/CD (Partie 7)
- ‚úÖ `Dockerfile` - Image guestbook (Partie 7)
- ‚úÖ `index.html` - Page HTML (Partie 7)
- ‚úÖ `renovate-deployment.yaml` - Bot Renovate (Partie 8)
- ‚úÖ `argocd-application.yaml` - GitOps application (Partie 9)
- ‚úÖ `chaos-pod-kill-experiment.yaml` - Exp√©rience Chaos (Partie 5)

### Fichiers d√©j√† existants (sessions pr√©c√©dentes)
- `resilient-app-deployment.yaml` (Partie 1)
- `resilient-app-service.yaml` (Partie 1)
- `guestbook-deployment.yaml` (Partie 3)
- `guestbook-ingress.yaml` (Partie 3)
- `guestbook-with-metrics.yaml` (Partie 4)
- `load-test.js` (Partie 3)
- `deploy-full-tp.sh` - Script automatisation
- `validate-all-parts.sh` - Script validation
- `apprentissage.md` - Documentation personnelle

### Nouveaux fichiers de documentation
- ‚úÖ `RECAP.md` - R√©capitulatif complet
- ‚úÖ `STATUS.md` - Ce fichier

---

## ‚úÖ CONCLUSION

**üéâ F√©licitations ! 9 parties sur 13 sont pr√©par√©es et pr√™tes au d√©ploiement.**

**Parties compl√®tement valid√©es (0-4) :** Infrastructure solide avec r√©silience, monitoring et load testing ‚úÖ

**Parties pr√©par√©es (5-9) :** Tous les fichiers YAML et workflows sont cr√©√©s, il ne reste que :
- Configuration de tokens/secrets
- Ex√©cution des commandes de d√©ploiement
- Validation des r√©sultats

**Prochaine √©tape recommand√©e :** Red√©marrer le cluster puis d√©ployer la Partie 5 (Chaos Mesh) en 10 minutes.

---

**Date de g√©n√©ration :** 9 janvier 2025  
**Auteur :** Brahim Hmitti  
**Repository :** github.com/BrahimHmitti/DEVOPS-jour4